<!DOCTYPE html>
<html>
  <head>
    <!--
      ========================================================================
      SuperSlides - Sidebar.html
      ========================================================================
      
      This is the sidebar UI that appears when users click SuperSlides > Open Sidebar.
      
      Key concepts:
      - This HTML runs in an IFRAME inside Google Slides (client-side/browser)
      - It CANNOT directly access Google Slides data or APIs
      - To do anything useful, it must call server-side functions in Code.gs
      - Communication happens via google.script.run (a special Apps Script bridge)
      
      Architecture:
      
        [Sidebar HTML/JS]  ←—google.script.run—→  [Code.gs on Google servers]
              ↓                                           ↓
        User sees UI                              Accesses Slides API
        Handles clicks                            Reads/moves shapes
        Shows status                              Stores properties
      
      ========================================================================
    -->
    
    <!--
      base target="_top" is a Google Apps Script best practice.
      
      The sidebar runs in an iframe. Without this, if you add any links (<a href>),
      they would try to open inside the tiny iframe instead of in a new tab.
      target="_top" makes links open in the main browser window.
    -->
    <base target="_top">

    <style>
      /*
        ======================================================================
        STYLES
        ======================================================================
        
        Minimal styling for MVP.
        Later we'll replace this with a proper design system including:
        - Custom colors and spacing variables
        - SVG icons for buttons
        - Hover/active states
        - Grouped button layouts
      */
      
      /* Base body styles */
      body {
        font-family: Arial, sans-serif;  /* Clean, readable font */
        padding: 12px;                   /* Space around content */
      }

      /* Remove default top margin from heading */
      h3 {
        margin-top: 0;
      }

      /* Button styles - all buttons are full-width blocks */
      button {
        display: block;      /* Stack buttons vertically */
        width: 100%;         /* Full width of sidebar */
        margin: 8px 0;       /* Vertical spacing between buttons */
        padding: 8px;        /* Inner padding for click target */
        font-size: 14px;     /* Readable text size */
        cursor: pointer;     /* Show hand cursor on hover */
      }

      /* Status text area at the bottom */
      #status {
        margin-top: 12px;    /* Space above status */
        font-size: 12px;     /* Smaller text for status */
        color: #555;         /* Gray color - less prominent than buttons */
      }
    </style>
  </head>

  <body>
    <!--
      ======================================================================
      HTML STRUCTURE
      ======================================================================
      
      The sidebar is organized into sections:
      1. Title
      2. Anchor controls (Set/Clear)
      3. Alignment controls (Align Left, Align Right, etc.)
      4. Status display
      
      Each button has an onclick handler that calls a JavaScript function
      defined in the <script> section below.
    -->
    
    <!-- Sidebar title - matches the menu name -->
    <h3>SuperSlides</h3>

    <!-- 
      ANCHOR CONTROLS
      
      Set Anchor: Saves the currently selected shape as the reference point
      Clear Anchor: Removes the saved anchor, reverts to fallback behavior
    -->
    <button onclick="runSetAnchor()">Set Anchor</button>
    <button onclick="runClearAnchor()">Clear Anchor</button>

    <!-- Visual separator between anchor and alignment controls -->
    <hr>

    <!-- 
      POSITION & ALIGNMENT SECTION
      
      This section contains all position and alignment features:
      1. Basic alignment (edges and centers)
      2. Position manipulation (swap)
      3. Distribution (equal spacing)
      4. Docking (touch edges)
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Position & Alignment</h4>

    <!-- 
      BASIC ALIGNMENT
      
      These buttons align selected shapes relative to the anchor.
      User should select 2+ shapes before clicking.
      
      Horizontal alignment (shapes move left/right):
      - Align Left: left edges line up
      - Align Right: right edges line up
      - Align Center: horizontal centers line up
      
      Vertical alignment (shapes move up/down):
      - Align Top: top edges line up
      - Align Bottom: bottom edges line up
      - Align Middle: vertical centers line up
    -->
    <button onclick="runAlignLeft()">Align Left</button>
    <button onclick="runAlignRight()">Align Right</button>
    <button onclick="runAlignCenter()">Align Center</button>
    <button onclick="runAlignTop()">Align Top</button>
    <button onclick="runAlignBottom()">Align Bottom</button>
    <button onclick="runAlignMiddle()">Align Middle</button>

    <!-- 
      POSITION MANIPULATION
      
      Swap Positions: Exchange the positions of exactly 2 selected shapes.
      Only position (left, top) is swapped - size and styling remain unchanged.
    -->
    <button onclick="runSwapPositions()">Swap Positions</button>

    <!-- 
      DISTRIBUTION
      
      Distribute shapes with equal spacing between them.
      - Horizontal: Equal gaps from left to right
      - Vertical: Equal gaps from top to bottom
      
      Requires at least 3 shapes. Leftmost/rightmost (or topmost/bottommost) 
      shapes stay fixed as anchors.
    -->
    <button onclick="runDistributeHorizontally()">Distribute Horizontally</button>
    <button onclick="runDistributeVertically()">Distribute Vertically</button>

    <!-- 
      DOCKING
      
      Move shapes until they "touch" the anchor's edges.
      Creates precisely aligned layouts with no gaps.
      
      All docking operations require an anchor (use Set Anchor first).
      Multiple shapes will stack at the same position.
    -->
    <button onclick="runDockLeft()">Dock Left</button>
    <button onclick="runDockRight()">Dock Right</button>
    <button onclick="runDockTop()">Dock Top</button>
    <button onclick="runDockBottom()">Dock Bottom</button>

    <hr>

    <!-- 
      TABLE ALIGNMENT CONTROLS
      
      These buttons align shapes within their containing table cells.
      User should:
      1. Have a table on the slide
      2. Select shapes that are inside table cells
      3. Specify padding (distance from cell edge)
      4. Click alignment button
      
      Shapes are aligned within their cells, not relative to each other.
      Multiple shapes in the same cell are stacked vertically.

      NEW TABLE SWAP FEATURES:
      - Swap Rows in Table: exchange contents of two row indices
      - Swap Columns in Table: exchange contents of two column indices
      - Uses 1-based indexing in UI for user-friendly input
      - Designed to avoid cut/paste workflows that can alter formatting context
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Table Alignment</h4>
    <button onclick="showTableAlignDialog()">Align in Table</button>
    <button onclick="showTableSwapDialog('row')">Swap Rows in Table</button>
    <button onclick="showTableSwapDialog('column')">Swap Columns in Table</button>
    
    <!-- Modal Dialog for Table Alignment -->
    <div id="tableAlignModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 250px;">
        <h3 style="margin-top: 0; margin-bottom: 16px; font-size: 16px;">Align in Table</h3>
        
        <div style="margin-bottom: 16px;">
          <label style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 8px;">Alignment:</label>
          <label style="display: block; margin-bottom: 6px; font-size: 13px;">
            <input type="radio" name="tableAlign" value="left" checked style="margin-right: 6px;">
            Left
          </label>
          <label style="display: block; margin-bottom: 6px; font-size: 13px;">
            <input type="radio" name="tableAlign" value="center" style="margin-right: 6px;">
            Center
          </label>
          <label style="display: block; margin-bottom: 6px; font-size: 13px;">
            <input type="radio" name="tableAlign" value="right" style="margin-right: 6px;">
            Right
          </label>
        </div>
        
        <div style="margin-bottom: 16px;">
          <label for="modalTablePadding" style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 4px;">Padding (points):</label>
          <input type="number" id="modalTablePadding" value="10" min="0" style="width: 100%; padding: 6px; box-sizing: border-box; font-size: 13px;">
        </div>
        
        <div style="display: flex; gap: 8px; justify-content: flex-end;">
          <button onclick="hideTableAlignDialog()" style="background: #ddd; color: #333;">Cancel</button>
          <button onclick="runTableAlign()" style="background: #4285f4; color: white;">Apply</button>
        </div>
      </div>
    </div>

    <!--
      Modal Dialog for Table Row/Column Swap

      This dialog is reused for both operations:
      - Row mode: prompts for "First row" + "Second row"
      - Column mode: prompts for "First column" + "Second column"

      Implementation detail:
      - Current mode is stored in hidden input #tableSwapMode
      - Labels/title are swapped dynamically by showTableSwapDialog(mode)
    -->
    <div id="tableSwapModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 250px;">
        <h3 id="tableSwapTitle" style="margin-top: 0; margin-bottom: 16px; font-size: 16px;">Swap in Table</h3>
        <input type="hidden" id="tableSwapMode" value="row">

        <div style="margin-bottom: 12px;">
          <label id="tableSwapFirstLabel" for="tableSwapFirst" style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 4px;">First row (1-based):</label>
          <input type="number" id="tableSwapFirst" value="1" min="1" style="width: 100%; padding: 6px; box-sizing: border-box; font-size: 13px;">
        </div>

        <div style="margin-bottom: 16px;">
          <label id="tableSwapSecondLabel" for="tableSwapSecond" style="font-size: 13px; font-weight: bold; display: block; margin-bottom: 4px;">Second row (1-based):</label>
          <input type="number" id="tableSwapSecond" value="2" min="1" style="width: 100%; padding: 6px; box-sizing: border-box; font-size: 13px;">
        </div>

        <div style="margin-bottom: 16px;">
          <label style="display: flex; align-items: center; gap: 8px; font-size: 13px;">
            <input type="checkbox" id="tableSwapKeepFormatting">
            Keep source text style + cell formatting (fill/alignment)
          </label>
          <div style="margin-top: 4px; font-size: 11px; color: #666;">
            Note: Table border swap is not supported by Google Apps Script.
          </div>
        </div>

        <div style="display: flex; gap: 8px; justify-content: flex-end;">
          <button onclick="hideTableSwapDialog()" style="background: #ddd; color: #333;">Cancel</button>
          <button onclick="runTableSwap()" style="background: #4285f4; color: white;">Apply</button>
        </div>
      </div>
    </div>

    <hr>

    <!-- 
      MATRIX ALIGNMENT CONTROLS
      
      Arranges selected shapes into a grid/matrix layout.
      User should:
      1. Select shapes to arrange
      2. Specify desired rows and columns
      3. Specify spacing between shapes
      4. Click "Arrange in Matrix"
      
      Features:
      - Auto-expands dimensions if shapes don't fit (e.g., 10 shapes in 3x3 → 4x3)
      - Maintains selection order (shapes not sorted by position)
      - Uses selection bounds as reference area
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Matrix Alignment</h4>
    <label for="matrixRows" style="font-size: 12px; color: #666;">Rows:</label>
    <input type="number" id="matrixRows" value="3" min="1" style="width: 100%; padding: 4px; margin-bottom: 8px; box-sizing: border-box;">
    <label for="matrixCols" style="font-size: 12px; color: #666;">Columns:</label>
    <input type="number" id="matrixCols" value="3" min="1" style="width: 100%; padding: 4px; margin-bottom: 8px; box-sizing: border-box;">
    <label for="matrixSpacing" style="font-size: 12px; color: #666;">Spacing (points):</label>
    <input type="number" id="matrixSpacing" value="20" min="0" style="width: 100%; padding: 4px; margin-bottom: 8px; box-sizing: border-box;">
    <button onclick="runArrangeMatrix()">Arrange in Matrix</button>

    <hr>

    <!-- 
      SLIDE LAYOUT SECTION
      
      Quickly insert common slide layouts with pre-formatted text boxes.
      
      Features:
      - Insert 2, 3, or 4 column layouts with title and content boxes
      - Insert footnote bars at the bottom of slides
      - All text boxes are properly positioned and formatted
      
      Column layouts include:
      - Title boxes: 1 inch tall, 16pt bold text
      - Content boxes: 3 inches tall, 14pt text
      - Gap between title and content: 0.05 inches
      - Gap between columns: 0.2 inches
      
      Usage:
      1. Click on a slide in the main canvas
      2. Click one of the column layout buttons (2, 3, or 4 columns)
      3. The text boxes will be automatically inserted and formatted
      4. Edit the placeholder text as needed
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Slide Layout</h4>
    <button onclick="runInsertTwoColumns()">Insert 2 Columns</button>
    <button onclick="runInsertThreeColumns()">Insert 3 Columns</button>
    <button onclick="runInsertFourColumns()">Insert 4 Columns</button>
    <button onclick="runInsertFootnote()">Insert Footnote</button>

    <hr>

    <!--
      SIZE MANIPULATION SECTION

      Align the size of selected objects to match the anchor's dimensions.

      Features:
      - Align Width: Make all selected objects the same width as anchor
      - Align Height: Make all selected objects the same height as anchor
      - Align Both: Make all selected objects the same width AND height as anchor

      Usage:
      1. Select 2 or more objects
      2. (Optional) Set an anchor, or the last selected object will be used
      3. Click one of the size alignment buttons
      4. All non-anchor objects will be resized to match the anchor's dimensions
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Size Manipulation</h4>
    <button onclick="runAlignWidth()">Align Width</button>
    <button onclick="runAlignHeight()">Align Height</button>
    <button onclick="runAlignBoth()">Align Both</button>

    <hr>

    <!--
      STRETCH OBJECTS SECTION

      Stretch selected objects to align their edges with the anchor's edges.
      Unlike "Align Size", this extends one edge while keeping the opposite edge fixed.

      Features:
      - Stretch Left: Extend left edge to anchor's left (right edge stays)
      - Stretch Right: Extend right edge to anchor's right (left edge stays)
      - Stretch Top: Extend top edge to anchor's top (bottom edge stays)
      - Stretch Bottom: Extend bottom edge to anchor's bottom (top edge stays)

      Usage:
      1. Select 2 or more objects
      2. (Optional) Set an anchor, or the last selected object will be used
      3. Click one of the stretch buttons
      4. Selected objects will extend in that direction to match the anchor's edge
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Stretch Objects</h4>
    <button onclick="runStretchLeft()">Stretch Left</button>
    <button onclick="runStretchRight()">Stretch Right</button>
    <button onclick="runStretchTop()">Stretch Top</button>
    <button onclick="runStretchBottom()">Stretch Bottom</button>

    <hr>

    <!--
      FILL SPACE SECTION

      Fill the gap between selected objects and the anchor by stretching.
      Only works when there is actual space/gap between the objects.

      Features:
      - Fill Left: Stretch left until touching anchor's right edge
      - Fill Right: Stretch right until touching anchor's left edge
      - Fill Top: Stretch up until touching anchor's bottom edge
      - Fill Bottom: Stretch down until touching anchor's top edge

      Usage:
      1. Select 2 or more objects with gaps between them
      2. (Optional) Set an anchor, or the last selected object will be used
      3. Click one of the fill buttons
      4. Objects will stretch to close the gap with the anchor
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Fill Space</h4>
    <button onclick="runFillLeft()">Fill Left</button>
    <button onclick="runFillRight()">Fill Right</button>
    <button onclick="runFillTop()">Fill Top</button>
    <button onclick="runFillBottom()">Fill Bottom</button>

    <hr>

    <!--
      MAGIC RESIZER SECTION

      Scale selected objects by a percentage factor.
      Opens an interactive dialog for precise control.

      Features:
      - User inputs a percentage (e.g., 50%, 120%, 200%)
      - All selected objects are scaled proportionally
      - 100% = no change, 50% = half size, 200% = double size

      Usage:
      1. Select 1 or more objects
      2. Click "Magic Resizer" button
      3. Enter desired percentage in the dialog
      4. Click "Apply" to resize
    -->
    <h4 style="margin-top: 16px; margin-bottom: 8px;">Magic Resizer</h4>
    <button onclick="runMagicResizer()">Magic Resizer</button>

    <hr>

    <!-- 
      STATUS DISPLAY
      
      Shows feedback to the user:
      - Current anchor state (on load)
      - "Aligning..." during operations
      - Success/error messages after operations
    -->
    <div id="status">Loading…</div>

    <!--
      ======================================================================
      CLIENT-SIDE JAVASCRIPT
      ======================================================================
      
      This JavaScript runs in the browser (inside the sidebar iframe).
      It handles:
      - Button click events
      - Calling server-side functions via google.script.run
      - Updating the UI with results
      
      IMPORTANT: google.script.run is ASYNCHRONOUS
      - The call returns immediately (doesn't wait for server)
      - You provide callbacks to handle success/failure
      - withSuccessHandler() - called when server function succeeds
      - withFailureHandler() - called when server function throws an error
    -->
    <script>
      /**
       * refreshStatus()
       *
       * Fetches the current anchor status from the server and displays it.
       * Called when the sidebar first loads, and after anchor operations.
       * 
       * How google.script.run works:
       * 1. google.script.run creates a connection to the server
       * 2. .withSuccessHandler(callback) registers a function to call on success
       * 3. .getAnchorStatus() is the server function name (defined in Code.gs)
       * 4. When server responds, callback receives the return value as argument
       */
      function refreshStatus() {
        google.script.run
          .withSuccessHandler(function (text) {
            // 'text' is whatever getAnchorStatus() returned
            // Update the status div with this text
            document.getElementById('status').innerText = text;
          })
          .getAnchorStatus();  // Call the server-side function
      }

      /**
       * runSetAnchor()
       *
       * Called when user clicks "Set Anchor" button.
       * 
       * Flow:
       * 1. Calls server-side setAnchor() function
       * 2. setAnchor() stores the selected element's ID
       * 3. On success, refreshStatus() is called to update the display
       * 
       * Note: We pass refreshStatus as the success handler (not refreshStatus())
       * This means "call this function when done", not "call it now"
       */
      function runSetAnchor() {
        google.script.run
          .withSuccessHandler(refreshStatus)  // After success, refresh the status
          .setAnchor();                       // Call server function
      }

      /**
       * runClearAnchor()
       *
       * Called when user clicks "Clear Anchor" button.
       * Similar to runSetAnchor - clears the anchor then refreshes status.
       */
      function runClearAnchor() {
        google.script.run
          .withSuccessHandler(refreshStatus)
          .clearAnchor();
      }

      /**
       * runAlignLeft()
       *
       * Called when user clicks "Align Left" button.
       * 
       * This has more complex handling than anchor functions because:
       * 1. We want immediate feedback ("Aligning left...")
       * 2. We want to show the result message from the server
       * 3. We want to catch and display any errors
       * 
       * Flow:
       * 1. Immediately show "Aligning left..." (user knows click worked)
       * 2. Call server-side alignLeft()
       * 3. On success: show the return message (e.g., "Aligned 3 element(s)...")
       * 4. On failure: show the error with ❌ prefix
       */
      function runAlignLeft() {
        // Immediate feedback - show user that button click was registered
        document.getElementById('status').innerText = 'Aligning left…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            // 'msg' is the string returned by alignLeft()
            // If msg is empty/null for some reason, show generic "Aligned."
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            // 'err' is an Error object if the server function threw an exception
            // Display the error message to help with debugging
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignLeft();  // Call server function
      }

      /**
       * runAlignRight()
       *
       * Called when user clicks "Align Right" button.
       * Same pattern as runAlignLeft - immediate feedback, success/error handling.
       */
      function runAlignRight() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Aligning right…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignRight();
      }

      /**
       * runAlignTop()
       *
       * Called when user clicks "Align Top" button.
       * 
       * This aligns the TOP edges of all selected shapes to the anchor's top edge.
       * Shapes move vertically (up/down) while keeping their horizontal position.
       * 
       * Same pattern as other alignment functions:
       * 1. Show immediate feedback ("Aligning top...")
       * 2. Call server-side alignTop()
       * 3. Display result or error
       */
      function runAlignTop() {
        // Immediate feedback - show user that button click was registered
        document.getElementById('status').innerText = 'Aligning top…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            // 'msg' is the string returned by alignTop()
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            // Display the error message to help with debugging
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignTop();  // Call server function
      }

      /**
       * runAlignBottom()
       *
       * Called when user clicks "Align Bottom" button.
       * 
       * This aligns the BOTTOM edges of all selected shapes to the anchor's bottom edge.
       * Shapes move vertically (up/down) while keeping their horizontal position.
       * 
       * Note: Like alignRight, this requires calculating where each shape's TOP
       * needs to be so that its BOTTOM aligns with the anchor's bottom.
       */
      function runAlignBottom() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Aligning bottom…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignBottom();
      }

      /**
       * runAlignCenter()
       *
       * Called when user clicks "Align Center" button.
       * 
       * This aligns the HORIZONTAL CENTERS of all selected shapes to the anchor's center.
       * Shapes move horizontally (left/right) while keeping their vertical position.
       * 
       * Note: This is center-based alignment, not edge-based. Each shape's center
       * point aligns with the anchor's center, regardless of shape width.
       */
      function runAlignCenter() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Aligning center…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignCenter();
      }

      /**
       * runAlignMiddle()
       *
       * Called when user clicks "Align Middle" button.
       * 
       * This aligns the VERTICAL CENTERS of all selected shapes to the anchor's center.
       * Shapes move vertically (up/down) while keeping their horizontal position.
       * 
       * Note: This is center-based alignment, not edge-based. Each shape's center
       * point aligns with the anchor's center, regardless of shape height.
       */
      function runAlignMiddle() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Aligning middle…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignMiddle();
      }

      /**
       * runSwapPositions()
       *
       * Called when user clicks "Swap Positions" button.
       * 
       * Swaps the positions of exactly two selected shapes.
       * Only position (left, top) is swapped - size, rotation, and styling remain unchanged.
       * 
       * Requires exactly 2 shapes to be selected.
       */
      function runSwapPositions() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Swapping positions…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Swapped.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .swapPositions();
      }

      /**
       * runDistributeHorizontally()
       *
       * Called when user clicks "Distribute Horizontally" button.
       * 
       * Distributes selected shapes evenly across horizontal space with equal gaps.
       * The leftmost and rightmost shapes stay fixed; middle shapes are repositioned.
       * 
       * Requires at least 3 shapes to be selected.
       */
      function runDistributeHorizontally() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Distributing horizontally…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Distributed.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .distributeHorizontally();
      }

      /**
       * runDistributeVertically()
       *
       * Called when user clicks "Distribute Vertically" button.
       * 
       * Distributes selected shapes evenly across vertical space with equal gaps.
       * The topmost and bottommost shapes stay fixed; middle shapes are repositioned.
       * 
       * Requires at least 3 shapes to be selected.
       */
      function runDistributeVertically() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Distributing vertically…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Distributed.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .distributeVertically();
      }

      /**
       * runDockLeft()
       *
       * Called when user clicks "Dock Left" button.
       * 
       * Moves selected shapes until their RIGHT edges touch the anchor's LEFT edge.
       * Creates a "docked to the left" effect.
       * 
       * Note: Multiple shapes will stack at the same position.
       * Requires at least 2 shapes (anchor + shapes to dock).
       */
      function runDockLeft() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Docking left…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Docked.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .dockLeft();
      }

      /**
       * runDockRight()
       *
       * Called when user clicks "Dock Right" button.
       * 
       * Moves selected shapes until their LEFT edges touch the anchor's RIGHT edge.
       * Creates a "docked to the right" effect.
       * 
       * Note: Multiple shapes will stack at the same position.
       * Requires at least 2 shapes (anchor + shapes to dock).
       */
      function runDockRight() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Docking right…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Docked.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .dockRight();
      }

      /**
       * runDockTop()
       *
       * Called when user clicks "Dock Top" button.
       * 
       * Moves selected shapes until their BOTTOM edges touch the anchor's TOP edge.
       * Creates a "docked above" effect.
       * 
       * Note: Multiple shapes will stack at the same position.
       * Requires at least 2 shapes (anchor + shapes to dock).
       */
      function runDockTop() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Docking top…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Docked.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .dockTop();
      }

      /**
       * runDockBottom()
       *
       * Called when user clicks "Dock Bottom" button.
       * 
       * Moves selected shapes until their TOP edges touch the anchor's BOTTOM edge.
       * Creates a "docked below" effect.
       * 
       * Note: Multiple shapes will stack at the same position.
       * Requires at least 2 shapes (anchor + shapes to dock).
       */
      function runDockBottom() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Docking bottom…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Docked.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .dockBottom();
      }

      /**
       * showTableAlignDialog()
       *
       * Shows the modal dialog for table alignment options.
       */
      function showTableAlignDialog() {
        document.getElementById('tableAlignModal').style.display = 'block';
      }

      /**
       * hideTableAlignDialog()
       *
       * Hides the modal dialog for table alignment options.
       */
      function hideTableAlignDialog() {
        document.getElementById('tableAlignModal').style.display = 'none';
      }

      /**
       * runTableAlign()
       *
       * Executes table alignment with user-selected options from the dialog.
       * 
       * Reads the selected alignment (left/center/right) and padding value,
       * then calls the server-side alignToTable function.
       */
      function runTableAlign() {
        // Get selected alignment
        const alignmentRadios = document.getElementsByName('tableAlign');
        let alignment = 'left'; // default
        for (let radio of alignmentRadios) {
          if (radio.checked) {
            alignment = radio.value;
            break;
          }
        }
        
        // Get padding value
        const padding = parseFloat(document.getElementById('modalTablePadding').value) || 10;
        
        // Hide the dialog
        hideTableAlignDialog();
        
        // Show status
        document.getElementById('status').innerText = 'Aligning to table (' + alignment + ')…';
        
        // Call server function
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignToTable(alignment, padding);
      }

      /**
       * showTableSwapDialog(mode)
       *
       * Shows the shared swap modal for row or column operations.
       *
       * What this function configures:
       * 1. Stores active mode ('row' or 'column') in a hidden input
       * 2. Updates modal title text to match selected operation
       * 3. Updates both field labels to match row/column language
       * 4. Displays modal
       *
       * @param {string} mode - 'row' or 'column'
       */
      function showTableSwapDialog(mode) {
        // Strictly treat only 'row' as row mode; any other value maps to column mode.
        const isRowMode = mode === 'row';

        // Persist mode so runTableSwap() knows which server function to call.
        document.getElementById('tableSwapMode').value = isRowMode ? 'row' : 'column';

        // Update title and labels dynamically to keep one reusable modal.
        document.getElementById('tableSwapTitle').innerText = isRowMode ? 'Swap Rows in Table' : 'Swap Columns in Table';
        document.getElementById('tableSwapFirstLabel').innerText = isRowMode ? 'First row (1-based):' : 'First column (1-based):';
        document.getElementById('tableSwapSecondLabel').innerText = isRowMode ? 'Second row (1-based):' : 'Second column (1-based):';

        // Show modal overlay.
        document.getElementById('tableSwapModal').style.display = 'block';
      }

      /**
       * hideTableSwapDialog()
       *
       * Hides the row/column swap modal overlay.
       */
      function hideTableSwapDialog() {
        document.getElementById('tableSwapModal').style.display = 'none';
      }

      /**
       * runTableSwap()
       *
       * Executes the selected table swap action.
       *
       * Flow:
       * 1. Read mode and index inputs from modal
       * 2. Validate that both indices are positive integers
       * 3. Close modal and show progress status
       * 4. Build a single google.script.run runner with success/error handlers
       * 5. Dispatch to swapTableRows(...) or swapTableColumns(...)
       */
      function runTableSwap() {
        // Read operation mode configured by showTableSwapDialog().
        const mode = document.getElementById('tableSwapMode').value;

        // Parse input values as base-10 integers (UI is 1-based).
        const first = parseInt(document.getElementById('tableSwapFirst').value, 10);
        const second = parseInt(document.getElementById('tableSwapSecond').value, 10);
        const keepFormatting = document.getElementById('tableSwapKeepFormatting').checked;

        // Client-side validation for fast feedback before server call.
        if (!Number.isInteger(first) || !Number.isInteger(second) || first < 1 || second < 1) {
          document.getElementById('status').innerText = '❌ Error: Enter valid positive whole numbers.';
          return;
        }

        // Hide modal once input is accepted.
        hideTableSwapDialog();

        // Show operation-specific progress status.
        if (mode === 'row') {
          document.getElementById('status').innerText = keepFormatting ?
            'Swapping rows in table (with source formatting)…' :
            'Swapping rows in table…';
        } else {
          document.getElementById('status').innerText = keepFormatting ?
            'Swapping columns in table (with source formatting)…' :
            'Swapping columns in table…';
        }

        // Create shared runner so both paths have identical result/error handling.
        const runner = google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Swapped.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          });

        // Dispatch to server function based on selected mode.
        if (mode === 'row') {
          runner.swapTableRows(first, second, keepFormatting);
        } else {
          runner.swapTableColumns(first, second, keepFormatting);
        }
      }

      /**
       * runArrangeMatrix()
       *
       * Called when user clicks "Arrange in Matrix" button.
       * 
       * Arranges selected shapes into a grid/matrix layout with user-specified
       * dimensions and spacing.
       * 
       * Features:
       * - Auto-expands dimensions if shapes don't fit requested size
       * - Maintains selection order (shapes not sorted)
       * - Uses selection bounds as reference area
       */
      function runArrangeMatrix() {
        const rows = parseInt(document.getElementById('matrixRows').value) || 3;
        const cols = parseInt(document.getElementById('matrixCols').value) || 3;
        const spacing = parseFloat(document.getElementById('matrixSpacing').value) || 20;
        
        // Validate inputs
        if (rows <= 0 || cols <= 0) {
          document.getElementById('status').innerText = '❌ Error: Rows and columns must be positive numbers.';
          return;
        }
        
        if (spacing < 0) {
          document.getElementById('status').innerText = '❌ Error: Spacing cannot be negative.';
          return;
        }
        
        document.getElementById('status').innerText = 'Arranging in matrix…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Arranged.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .arrangeMatrix(rows, cols, spacing);
      }

      /**
       * runInsertTwoColumns()
       *
       * Called when user clicks "Insert 2 Columns" button.
       * 
       * Inserts a 2-column layout with title and content boxes.
       * Each column has a title box (Header 1, Header 2) and content box (Content 1, Content 2).
       * 
       * Requirements:
       * - User must have a slide selected (not master or layout)
       */
      function runInsertTwoColumns() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Inserting 2 columns…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Inserted.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .insertTwoColumns();
      }

      /**
       * runInsertThreeColumns()
       *
       * Called when user clicks "Insert 3 Columns" button.
       * 
       * Inserts a 3-column layout with title and content boxes.
       * Each column has a title box (Header 1, 2, 3) and content box (Content 1, 2, 3).
       * 
       * Requirements:
       * - User must have a slide selected (not master or layout)
       */
      function runInsertThreeColumns() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Inserting 3 columns…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Inserted.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .insertThreeColumns();
      }

      /**
       * runInsertFourColumns()
       *
       * Called when user clicks "Insert 4 Columns" button.
       * 
       * Inserts a 4-column layout with title and content boxes.
       * Each column has a title box (Header 1-4) and content box (Content 1-4).
       * 
       * Note: With 4 columns, each column is narrower (~2.125 inches).
       * Consider using shorter text if content doesn't fit.
       * 
       * Requirements:
       * - User must have a slide selected (not master or layout)
       */
      function runInsertFourColumns() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Inserting 4 columns…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Inserted.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .insertFourColumns();
      }

      /**
       * runInsertFootnote()
       *
       * Called when user clicks "Insert Footnote" button.
       * 
       * Inserts a footnote text box at the bottom of the slide.
       * The footnote box is positioned at 4.8 inches from the top, spanning 9 inches wide.
       * 
       * Default text: "Footnote: 1. commentary 1, 2. commentary 2, 3. commentary 3"
       * Font size: 12pt
       * 
       * The text is fully editable after insertion - replace with your actual footnotes.
       * 
       * Requirements:
       * - User must have a slide selected (not master or layout)
       */
      function runInsertFootnote() {
        // Immediate feedback
        document.getElementById('status').innerText = 'Inserting footnote…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Inserted.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .insertFootnote();
      }

      // ====================================================================
      // SIZE MANIPULATION
      // ====================================================================

      /**
       * runAlignWidth()
       * 
       * Aligns the width of all selected objects to match the anchor's width.
       * Position and height remain unchanged.
       */
      function runAlignWidth() {
        document.getElementById('status').innerText = 'Aligning width…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Width aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignWidth();
      }

      /**
       * runAlignHeight()
       * 
       * Aligns the height of all selected objects to match the anchor's height.
       * Position and width remain unchanged.
       */
      function runAlignHeight() {
        document.getElementById('status').innerText = 'Aligning height…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Height aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignHeight();
      }

      /**
       * runAlignBoth()
       * 
       * Aligns both width AND height of all selected objects to match the anchor.
       * Position remains unchanged, but size becomes identical to anchor.
       */
      function runAlignBoth() {
        document.getElementById('status').innerText = 'Aligning size (both)…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Size aligned.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .alignBoth();
      }

      // ====================================================================
      // STRETCH OBJECTS
      // ====================================================================

      /**
       * runStretchLeft()
       * 
       * Extends objects' left edge to match anchor's left edge.
       * Right edge stays fixed (objects grow/shrink leftward).
       */
      function runStretchLeft() {
        document.getElementById('status').innerText = 'Stretching left…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Stretched left.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .stretchLeft();
      }

      /**
       * runStretchRight()
       * 
       * Extends objects' right edge to match anchor's right edge.
       * Left edge stays fixed (objects grow/shrink rightward).
       */
      function runStretchRight() {
        document.getElementById('status').innerText = 'Stretching right…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Stretched right.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .stretchRight();
      }

      /**
       * runStretchTop()
       * 
       * Extends objects' top edge to match anchor's top edge.
       * Bottom edge stays fixed (objects grow/shrink upward).
       */
      function runStretchTop() {
        document.getElementById('status').innerText = 'Stretching top…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Stretched top.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .stretchTop();
      }

      /**
       * runStretchBottom()
       * 
       * Extends objects' bottom edge to match anchor's bottom edge.
       * Top edge stays fixed (objects grow/shrink downward).
       */
      function runStretchBottom() {
        document.getElementById('status').innerText = 'Stretching bottom…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Stretched bottom.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .stretchBottom();
      }

      // ====================================================================
      // FILL SPACE
      // ====================================================================

      /**
       * runFillLeft()
       * 
       * Stretches objects to fill the gap between them and the anchor's right edge.
       * Only works when there is space between the object and anchor.
       */
      function runFillLeft() {
        document.getElementById('status').innerText = 'Filling left space…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Filled left.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .fillLeft();
      }

      /**
       * runFillRight()
       * 
       * Stretches objects to fill the gap between them and the anchor's left edge.
       * Only works when there is space between the object and anchor.
       */
      function runFillRight() {
        document.getElementById('status').innerText = 'Filling right space…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Filled right.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .fillRight();
      }

      /**
       * runFillTop()
       * 
       * Stretches objects to fill the gap between them and the anchor's bottom edge.
       * Only works when there is space between the object and anchor.
       */
      function runFillTop() {
        document.getElementById('status').innerText = 'Filling top space…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Filled top.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .fillTop();
      }

      /**
       * runFillBottom()
       * 
       * Stretches objects to fill the gap between them and the anchor's top edge.
       * Only works when there is space between the object and anchor.
       */
      function runFillBottom() {
        document.getElementById('status').innerText = 'Filling bottom space…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            document.getElementById('status').innerText = msg || 'Filled bottom.';
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .fillBottom();
      }

      // ====================================================================
      // MAGIC RESIZER
      // ====================================================================

      /**
       * runMagicResizer()
       * 
       * Opens a dialog for the user to input a percentage to resize selected objects.
       * Examples: 50% = half size, 200% = double size, 120% = 20% larger.
       */
      function runMagicResizer() {
        document.getElementById('status').innerText = 'Opening Magic Resizer…';
        
        google.script.run
          .withSuccessHandler(function (msg) {
            // Dialog handles its own status messages
            // This handler is mainly for error cases
            if (msg) {
              document.getElementById('status').innerText = msg;
            }
          })
          .withFailureHandler(function (err) {
            document.getElementById('status').innerText =
              '❌ Error: ' + (err && err.message ? err.message : JSON.stringify(err));
          })
          .showMagicResizerDialog();
      }

      // ====================================================================
      // INITIALIZATION
      // ====================================================================
      
      // When the sidebar HTML loads, immediately fetch and display
      // the current anchor status so user knows the state
      refreshStatus();
    </script>
  </body>
</html>
